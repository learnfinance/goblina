<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Ms. Goblina Content Creator</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      :root {
        color-scheme: dark;
        --bg: #05060a;
        --panel: #111320;
        --accent: #5b8dff;
        --accent-soft: rgba(91, 141, 255, 0.2);
        --accent-green: #34d399;
        --border-subtle: #272b3f;
        --text-main: #f3f4ff;
        --text-muted: #9ca3c7;
        --danger: #f97373;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text", sans-serif;
        background: radial-gradient(circle at top, #15182b 0, #05060a 55%);
        color: var(--text-main);
        min-height: 100vh;
        display: flex;
        align-items: stretch;
        justify-content: center;
      }

      .app-shell {
        width: 100%;
        max-width: 1200px;
        padding: 24px;
        display: flex;
        flex-direction: column;
        gap: 20px;
      }

      header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 12px;
      }

      .title-block h1 {
        margin: 0;
        font-size: 1.8rem;
        letter-spacing: 0.03em;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .pill {
        font-size: 0.7rem;
        text-transform: uppercase;
        padding: 3px 8px;
        border-radius: 999px;
        background: linear-gradient(135deg, var(--accent-soft), rgba(255, 255, 255, 0.02));
        border: 1px solid var(--accent-soft);
        color: var(--text-muted);
      }

      .title-block p {
        margin: 4px 0 0;
        color: var(--text-muted);
        font-size: 0.85rem;
      }

      /* Wizard Steps */
      .wizard-nav {
        display: flex;
        gap: 12px;
        overflow-x: auto;
        padding: 8px 0;
      }

      .wizard-step {
        flex: 1;
        min-width: 120px;
        padding: 10px 14px;
        border-radius: 12px;
        border: 1px solid var(--border-subtle);
        background: rgba(15, 23, 42, 0.6);
        cursor: pointer;
        transition: all 0.2s;
        text-align: center;
      }

      .wizard-step.active {
        border-color: var(--accent);
        background: var(--accent-soft);
        box-shadow: 0 0 12px rgba(91, 141, 255, 0.3);
      }

      .wizard-step.completed {
        border-color: var(--accent-green);
        background: rgba(52, 211, 153, 0.1);
      }

      .wizard-step .step-number {
        font-size: 0.7rem;
        color: var(--text-muted);
        margin-bottom: 4px;
      }

      .wizard-step .step-title {
        font-size: 0.85rem;
        font-weight: 500;
      }

      /* Panel */
      .panel {
        background: radial-gradient(circle at top left, rgba(91, 141, 255, 0.08), transparent 45%),
          radial-gradient(circle at bottom right, rgba(191, 90, 242, 0.12), transparent 50%),
          linear-gradient(145deg, #05060a, #080b14);
        border-radius: 20px;
        border: 1px solid var(--border-subtle);
        box-shadow:
          0 24px 60px rgba(0, 0, 0, 0.7),
          0 0 0 1px rgba(255, 255, 255, 0.03);
        padding: 24px;
      }

      .panel h2 {
        margin: 0 0 16px 0;
        font-size: 1.2rem;
      }

      /* Form Elements */
      label {
        display: block;
        font-size: 0.8rem;
        margin-bottom: 6px;
        color: var(--text-muted);
        font-weight: 500;
      }

      input[type="text"],
      select,
      textarea {
        width: 100%;
        padding: 10px 12px;
        border-radius: 10px;
        border: 1px solid var(--border-subtle);
        background: rgba(10, 12, 22, 0.9);
        color: var(--text-main);
        font-family: inherit;
        font-size: 0.9rem;
        outline: none;
        margin-bottom: 14px;
      }

      textarea {
        min-height: 100px;
        resize: vertical;
      }

      input:focus,
      select:focus,
      textarea:focus {
        border-color: var(--accent);
        box-shadow: 0 0 0 2px rgba(91, 141, 255, 0.3);
      }

      .upload-zone {
        border-radius: 12px;
        border: 2px dashed rgba(148, 163, 255, 0.5);
        background: radial-gradient(circle at top, rgba(91, 141, 255, 0.12), transparent 60%);
        padding: 24px;
        text-align: center;
        cursor: pointer;
        transition: all 0.2s;
        margin-bottom: 14px;
      }

      .upload-zone:hover {
        border-color: var(--accent);
        background: radial-gradient(circle at top, rgba(91, 141, 255, 0.18), transparent 60%);
      }

      .upload-zone.has-file {
        border-color: var(--accent-green);
        background: radial-gradient(circle at top, rgba(52, 211, 153, 0.12), transparent 60%);
      }

      .character-preview {
        max-width: 300px;
        max-height: 300px;
        border-radius: 12px;
        margin: 12px auto;
        display: block;
      }

      /* Buttons */
      .btn {
        border-radius: 999px;
        border: none;
        padding: 10px 20px;
        font-size: 0.9rem;
        font-weight: 500;
        cursor: pointer;
        display: inline-flex;
        align-items: center;
        gap: 8px;
        white-space: nowrap;
        transition: all 0.2s;
      }

      .btn-primary {
        background: linear-gradient(135deg, #5b8dff, #bf5af2);
        color: #ffffff;
        box-shadow:
          0 0 14px rgba(91, 141, 255, 0.5),
          0 0 34px rgba(191, 90, 242, 0.3);
      }

      .btn-primary:hover {
        box-shadow:
          0 0 20px rgba(91, 141, 255, 0.7),
          0 0 40px rgba(191, 90, 242, 0.5);
        transform: translateY(-1px);
      }

      .btn-secondary {
        background: rgba(15, 23, 42, 0.85);
        color: var(--text-main);
        border: 1px solid var(--border-subtle);
      }

      .btn:disabled {
        opacity: 0.5;
        cursor: default;
        box-shadow: none;
      }

      .btn-group {
        display: flex;
        gap: 10px;
        margin-top: 20px;
      }

      /* Preset Cards */
      .preset-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 12px;
        margin-bottom: 14px;
      }

      .preset-card {
        padding: 14px;
        border-radius: 12px;
        border: 1px solid var(--border-subtle);
        background: rgba(15, 23, 42, 0.6);
        cursor: pointer;
        transition: all 0.2s;
      }

      .preset-card:hover {
        border-color: var(--accent);
        transform: translateY(-2px);
      }

      .preset-card.selected {
        border-color: var(--accent);
        background: var(--accent-soft);
        box-shadow: 0 0 12px rgba(91, 141, 255, 0.3);
      }

      .preset-card h3 {
        margin: 0 0 6px 0;
        font-size: 0.95rem;
      }

      .preset-card p {
        margin: 0;
        font-size: 0.75rem;
        color: var(--text-muted);
      }

      /* Scenario Cards */
      .scenario-list {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .scenario-card {
        padding: 16px;
        border-radius: 12px;
        border: 1px solid var(--border-subtle);
        background: rgba(15, 23, 42, 0.6);
      }

      .scenario-card h3 {
        margin: 0 0 8px 0;
        font-size: 1rem;
        color: var(--accent);
      }

      .scenario-card .meta {
        font-size: 0.75rem;
        color: var(--text-muted);
        margin-bottom: 8px;
      }

      .scenario-card .dialogue {
        font-style: italic;
        margin: 8px 0;
        padding: 8px;
        background: rgba(91, 141, 255, 0.1);
        border-left: 3px solid var(--accent);
        border-radius: 4px;
      }

      .scenario-card .prompt {
        font-size: 0.8rem;
        color: var(--text-muted);
        margin-top: 8px;
        padding: 8px;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 6px;
        max-height: 100px;
        overflow-y: auto;
      }

      .prompt-editor {
        width: 100%;
        min-height: 120px;
        padding: 12px;
        border-radius: 8px;
        border: 1px solid var(--border-subtle);
        background: rgba(10, 12, 22, 0.9);
        color: var(--text-main);
        font-family: 'Monaco', 'Courier New', monospace;
        font-size: 0.85rem;
        line-height: 1.5;
        resize: vertical;
        margin-top: 8px;
      }

      .prompt-editor:focus {
        border-color: var(--accent);
        box-shadow: 0 0 0 2px rgba(91, 141, 255, 0.3);
        outline: none;
      }

      .prompt-review-card {
        padding: 20px;
        border-radius: 12px;
        border: 1px solid var(--border-subtle);
        background: rgba(15, 23, 42, 0.6);
        margin-bottom: 16px;
      }

      .prompt-review-card h3 {
        margin: 0 0 12px 0;
        font-size: 1rem;
        color: var(--accent);
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .prompt-review-card .meta-info {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        gap: 12px;
        margin-bottom: 12px;
      }

      .prompt-review-card .meta-item {
        font-size: 0.8rem;
        color: var(--text-muted);
      }

      .prompt-review-card .meta-item strong {
        color: var(--text-main);
        display: block;
        margin-bottom: 4px;
      }

      .expand-toggle {
        font-size: 0.8rem;
        color: var(--accent);
        cursor: pointer;
        user-select: none;
      }

      .expand-toggle:hover {
        text-decoration: underline;
      }

      /* Status */
      .status-pill {
        display: inline-block;
        border-radius: 999px;
        font-size: 0.7rem;
        padding: 4px 10px;
        text-transform: uppercase;
        letter-spacing: 0.06em;
        background: rgba(15, 23, 42, 0.95);
        border: 1px solid var(--border-subtle);
        color: var(--text-muted);
      }

      .status-pending {
        border-color: rgba(234, 179, 8, 0.8);
        color: #facc15;
      }

      .status-ok {
        border-color: rgba(52, 211, 153, 0.9);
        color: #6ee7b7;
      }

      .status-error {
        border-color: rgba(248, 113, 113, 0.9);
        color: var(--danger);
      }

      .loading {
        text-align: center;
        padding: 20px;
        color: var(--text-muted);
      }

      .hidden {
        display: none;
      }

      .error-text {
        color: var(--danger);
        font-size: 0.85rem;
        margin-top: 8px;
      }

      @keyframes spin {
        from { transform: rotate(0deg); }
        to { transform: rotate(360deg); }
      }

      /* Video Grid */
      .video-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
        gap: 16px;
      }

      .video-card {
        border-radius: 12px;
        border: 1px solid var(--border-subtle);
        background: rgba(15, 23, 42, 0.6);
        overflow: hidden;
      }

      .video-card video {
        width: 100%;
        display: block;
        background: #000;
      }

      .video-card .card-body {
        padding: 12px;
      }

      .video-card .card-title {
        font-size: 0.85rem;
        margin: 0 0 6px 0;
      }

      .video-card .card-actions {
        display: flex;
        gap: 8px;
        margin-top: 10px;
      }

      .btn-sm {
        padding: 6px 12px;
        font-size: 0.8rem;
      }

      .video-container {
        position: relative;
      }

      /* Snippet buttons */
      .snippet-btn {
        padding: 6px 12px;
        font-size: 0.75rem;
        border-radius: 20px;
        border: 1px solid var(--border-subtle);
        background: rgba(15, 23, 42, 0.8);
        color: var(--text-main);
        cursor: pointer;
        transition: all 0.2s;
        white-space: nowrap;
      }

      .snippet-btn:hover {
        border-color: var(--accent);
        background: var(--accent-soft);
        transform: translateY(-1px);
      }

      .snippet-btn.copied {
        border-color: var(--accent-green);
        background: rgba(52, 211, 153, 0.2);
      }

      /* Copy button */
      .copy-btn {
        padding: 4px 10px;
        font-size: 0.75rem;
        border-radius: 6px;
        border: 1px solid var(--border-subtle);
        background: rgba(15, 23, 42, 0.8);
        color: var(--text-muted);
        cursor: pointer;
        transition: all 0.2s;
      }

      .copy-btn:hover {
        border-color: var(--accent);
        color: var(--accent);
      }

      .copy-btn.copied {
        border-color: var(--accent-green);
        color: var(--accent-green);
      }

      /* Scenario action buttons */
      .scenario-actions {
        display: flex;
        gap: 8px;
        margin-top: 12px;
        padding-top: 12px;
        border-top: 1px solid var(--border-subtle);
      }

      .scenario-action-btn {
        padding: 6px 12px;
        font-size: 0.75rem;
        border-radius: 6px;
        border: 1px solid var(--border-subtle);
        background: transparent;
        color: var(--text-muted);
        cursor: pointer;
        transition: all 0.2s;
      }

      .scenario-action-btn:hover {
        border-color: var(--accent);
        color: var(--accent);
      }

      .scenario-action-btn.delete:hover {
        border-color: var(--danger);
        color: var(--danger);
      }

      /* Rating stars */
      .rating-stars {
        display: flex;
        gap: 4px;
      }

      .rating-star {
        font-size: 1.2rem;
        cursor: pointer;
        transition: transform 0.1s;
        opacity: 0.3;
      }

      .rating-star:hover {
        transform: scale(1.2);
      }

      .rating-star.active {
        opacity: 1;
      }

      /* Favorite button */
      .favorite-btn {
        font-size: 1.2rem;
        cursor: pointer;
        transition: all 0.2s;
        background: none;
        border: none;
        padding: 4px;
      }

      .favorite-btn:hover {
        transform: scale(1.1);
      }

      .favorite-btn.favorited {
        color: #f59e0b;
      }
    </style>
  </head>
  <body>
    <!-- Navigation Bar -->
    <nav style="
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      background: rgba(17, 19, 32, 0.95);
      backdrop-filter: blur(10px);
      border-bottom: 1px solid rgba(91, 141, 255, 0.2);
      padding: 12px 24px;
      display: flex;
      align-items: center;
      gap: 24px;
      z-index: 1000;
    ">
      <a href="/home.html" style="
        color: var(--text-main);
        text-decoration: none;
        font-weight: 600;
        font-size: 1.1rem;
      ">üé¨ Sora Creator</a>
      <div style="display: flex; gap: 16px; flex: 1;">
        <a href="/characters.html" style="
          color: var(--text-muted);
          text-decoration: none;
          padding: 6px 12px;
          border-radius: 8px;
          transition: all 0.2s;
        ">üë§ My Characters</a>
        <a href="/history.html" style="
          color: var(--text-muted);
          text-decoration: none;
          padding: 6px 12px;
          border-radius: 8px;
          transition: all 0.2s;
        ">üìú History</a>
        <a href="/templates.html" style="
          color: var(--text-muted);
          text-decoration: none;
          padding: 6px 12px;
          border-radius: 8px;
          transition: all 0.2s;
        ">üìö Templates</a>
        <a href="/queue.html" style="
          color: var(--text-muted);
          text-decoration: none;
          padding: 6px 12px;
          border-radius: 8px;
          transition: all 0.2s;
        ">üìä Queue</a>
        <a href="/creator.html" style="
          color: var(--accent);
          text-decoration: none;
          padding: 6px 12px;
          border-radius: 8px;
          background: rgba(91,141,255,0.1);
        ">
          üßô‚Äç‚ôÄÔ∏è Creator Wizard
        </a>
        <a href="/index.html" style="
          color: var(--text-muted);
          text-decoration: none;
          padding: 6px 12px;
          border-radius: 8px;
          transition: all 0.2s;
        ">
          ‚ö° Quick Generate
        </a>
      </div>
    </nav>

    <div class="app-shell" style="margin-top: 60px;">
      <header>
        <div class="title-block">
          <h1>
            üßô‚Äç‚ôÄÔ∏è Ms. Goblina Content Creator
            <span class="pill">Sora 2 ¬∑ Gen Z Memes</span>
          </h1>
          <p>Create relatable Instagram content with AI-powered character consistency</p>
        </div>
      </header>

      <!-- Wizard Navigation -->
      <div class="wizard-nav">
        <div class="wizard-step active" data-step="1">
          <div class="step-number">Step 1</div>
          <div class="step-title">Character</div>
        </div>
        <div class="wizard-step" data-step="2">
          <div class="step-number">Step 2</div>
          <div class="step-title">Personality</div>
        </div>
        <div class="wizard-step" data-step="3">
          <div class="step-number">Step 3</div>
          <div class="step-title">Topic/Story</div>
        </div>
        <div class="wizard-step" data-step="4">
          <div class="step-number">Step 4</div>
          <div class="step-title">Review Prompts</div>
        </div>
        <div class="wizard-step" data-step="5">
          <div class="step-number">Step 5</div>
          <div class="step-title">üçå Preview Images</div>
        </div>
        <div class="wizard-step" data-step="6">
          <div class="step-number">Step 6</div>
          <div class="step-title">Generate Video</div>
        </div>
      </div>

      <!-- Step 1: Character Setup -->
      <div class="panel" id="step-1">
        <h2>‚ú® Select or Upload Character</h2>
        <p style="color: var(--text-muted); margin-bottom: 16px;">
          Choose a saved character or upload a new one. AI will analyze the style for consistent video generation.
        </p>

        <!-- Saved Characters Selector -->
        <div id="saved-characters-section" style="margin-bottom: 20px;">
          <label>Use Saved Character</label>
          <select id="saved-character-select" style="width: 100%; padding: 10px 12px; border-radius: 10px; border: 1px solid var(--border-subtle); background: rgba(10, 12, 22, 0.9); color: var(--text-main); font-size: 0.9rem; margin-bottom: 10px;">
            <option value="">-- Upload New Character --</option>
          </select>
          <div id="saved-character-preview" class="hidden" style="padding: 12px; border-radius: 10px; background: rgba(52, 211, 153, 0.1); border: 1px solid var(--accent-green); margin-bottom: 16px;">
            <div style="display: flex; align-items: center; gap: 12px;">
              <img id="selected-char-image" style="width: 60px; height: 60px; border-radius: 8px; object-fit: cover; display: none;" />
              <span id="selected-char-emoji" style="font-size: 2rem;">üë§</span>
              <div style="flex: 1;">
                <div id="selected-char-name" style="font-weight: 600;"></div>
                <div id="selected-char-style" style="font-size: 0.8rem; color: var(--text-muted);"></div>
              </div>
            </div>
            <!-- NEXT BUTTON for saved character -->
            <button id="continue-with-saved-char" class="btn btn-primary" style="margin-top: 16px; width: 100%;">
              Continue with This Character ‚Üí
            </button>
          </div>
        </div>

        <div id="upload-new-character-section">
          <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px;">
            <div style="flex: 1; height: 1px; background: var(--border-subtle);"></div>
            <span style="color: var(--text-muted); font-size: 0.8rem;">OR UPLOAD NEW</span>
            <div style="flex: 1; height: 1px; background: var(--border-subtle);"></div>
          </div>

        <form id="character-form">
          <label for="character-name">Character Name</label>
          <input type="text" id="character-name" placeholder="Ms. Goblina" value="Ms. Goblina" />

          <div class="upload-zone" id="character-upload-zone">
            <div>üì∏ Click or drag character image here</div>
            <div style="font-size: 0.75rem; color: var(--text-muted); margin-top: 4px;">JPEG, PNG, or WebP</div>
            <input type="file" id="character-image" accept="image/jpeg,image/png,image/webp" style="display: none;" />
            <img id="character-preview" class="character-preview hidden" />
          </div>

          <div id="character-error" class="error-text hidden"></div>
          <div id="character-loading" class="loading hidden">üîÆ Analyzing character style with Vision API...</div>

          <div class="btn-group">
            <button type="submit" class="btn btn-primary" id="analyze-btn">
              Analyze Character Style ‚Üí
            </button>
          </div>
        </form>

        <div id="style-guide-preview" class="hidden" style="margin-top: 20px;">
          <h3 style="margin-bottom: 12px;">üìã Style Guide (Visual Editor)</h3>
          
          <!-- Visual Style Cards -->
          <div id="style-guide-visual" style="display: grid; gap: 16px;">
            <!-- Character Card -->
            <div style="padding: 16px; border-radius: 12px; background: rgba(91, 141, 255, 0.1); border: 1px solid rgba(91, 141, 255, 0.2);">
              <h4 style="margin: 0 0 12px; font-size: 0.9rem; color: var(--accent);">üë§ Character Appearance</h4>
              <div style="display: grid; gap: 12px;">
                <div>
                  <label style="font-size: 0.75rem; color: var(--text-muted);">Physical Description</label>
                  <textarea id="style-appearance" style="width: 100%; padding: 8px; border-radius: 8px; border: 1px solid var(--border-subtle); background: rgba(10,12,22,0.9); color: var(--text-main); min-height: 60px; resize: vertical;"></textarea>
                </div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
                  <div>
                    <label style="font-size: 0.75rem; color: var(--text-muted);">Visual Style</label>
                    <input type="text" id="style-visual" style="width: 100%; padding: 8px; border-radius: 8px; border: 1px solid var(--border-subtle); background: rgba(10,12,22,0.9); color: var(--text-main);" />
                  </div>
                  <div>
                    <label style="font-size: 0.75rem; color: var(--text-muted);">Artistic Style</label>
                    <input type="text" id="style-artistic" style="width: 100%; padding: 8px; border-radius: 8px; border: 1px solid var(--border-subtle); background: rgba(10,12,22,0.9); color: var(--text-main);" />
                  </div>
                </div>
        </div>
      </div>

            <!-- Color Palette Card -->
            <div style="padding: 16px; border-radius: 12px; background: rgba(52, 211, 153, 0.1); border: 1px solid rgba(52, 211, 153, 0.2);">
              <h4 style="margin: 0 0 12px; font-size: 0.9rem; color: var(--accent-green);">üé® Color Palette</h4>
              <div id="color-swatches" style="display: flex; gap: 8px; flex-wrap: wrap;"></div>
              <div style="margin-top: 12px;">
                <label style="font-size: 0.75rem; color: var(--text-muted);">Add Color (hex)</label>
                <div style="display: flex; gap: 8px;">
                  <input type="text" id="new-color" placeholder="#8BC34A" style="flex: 1; padding: 8px; border-radius: 8px; border: 1px solid var(--border-subtle); background: rgba(10,12,22,0.9); color: var(--text-main);" />
                  <button onclick="addColorSwatch()" style="padding: 8px 16px; border-radius: 8px; border: 1px solid var(--accent-green); background: transparent; color: var(--accent-green); cursor: pointer;">+ Add</button>
                </div>
              </div>
            </div>

            <!-- Lighting & Details Card -->
            <div style="padding: 16px; border-radius: 12px; background: rgba(251, 191, 36, 0.1); border: 1px solid rgba(251, 191, 36, 0.2);">
              <h4 style="margin: 0 0 12px; font-size: 0.9rem; color: #fbbf24;">üí° Lighting & Details</h4>
              <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
                <div>
                  <label style="font-size: 0.75rem; color: var(--text-muted);">Typical Lighting</label>
                  <input type="text" id="style-lighting" style="width: 100%; padding: 8px; border-radius: 8px; border: 1px solid var(--border-subtle); background: rgba(10,12,22,0.9); color: var(--text-main);" />
                </div>
                <div>
                  <label style="font-size: 0.75rem; color: var(--text-muted);">Distinctive Details</label>
                  <input type="text" id="style-details" style="width: 100%; padding: 8px; border-radius: 8px; border: 1px solid var(--border-subtle); background: rgba(10,12,22,0.9); color: var(--text-main);" />
                </div>
              </div>
            </div>
          </div>

          <!-- Toggle Raw JSON -->
          <div style="margin-top: 12px;">
            <button onclick="toggleRawJson()" style="padding: 6px 12px; font-size: 0.75rem; border-radius: 6px; border: 1px solid var(--border-subtle); background: transparent; color: var(--text-muted); cursor: pointer;">
              üìÑ Show Raw JSON
            </button>
          </div>
          <pre id="style-guide-json" class="hidden" style="background: rgba(0,0,0,0.4); padding: 12px; border-radius: 8px; overflow-x: auto; font-size: 0.75rem; margin-top: 12px;"></pre>
        </div>
        </div><!-- close upload-new-character-section -->
      </div>

      <!-- Step 2: Personality & Video Settings -->
      <div class="panel hidden" id="step-2">
        <h2>üé≠ Content Settings</h2>
        <p style="color: var(--text-muted); margin-bottom: 16px;">
          Configure personality, video format, and generation options.
        </p>

        <!-- Personality Presets -->
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
          <label style="margin: 0;">Content Personality</label>
          <button onclick="openCreatePresetModal()" style="padding: 6px 12px; font-size: 0.8rem; border-radius: 8px; border: 1px solid var(--accent); background: transparent; color: var(--accent); cursor: pointer;">
            + Create Custom
          </button>
        </div>
        <div class="preset-grid" id="personality-presets"></div>
        
        <!-- Custom Presets Section -->
        <div id="custom-presets-section" class="hidden" style="margin-top: 16px;">
          <label style="margin-bottom: 8px; display: block; color: var(--accent-green);">‚ú® Your Custom Presets</label>
          <div class="preset-grid" id="custom-presets"></div>
        </div>

        <!-- Video Settings -->
        <div style="margin-top: 24px; padding-top: 20px; border-top: 1px solid var(--border-subtle);">
          <h3 style="margin: 0 0 16px; font-size: 1rem;">‚öôÔ∏è Video Settings</h3>
          
          <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 16px;">
            <!-- Duration -->
            <div>
              <label for="video-duration">Duration (seconds)</label>
              <select id="video-duration" style="width: 100%; padding: 10px; border-radius: 10px; border: 1px solid var(--border-subtle); background: rgba(10, 12, 22, 0.9); color: var(--text-main);">
                <option value="5">5 seconds</option>
                <option value="8" selected>8 seconds</option>
                <option value="10">10 seconds</option>
                <option value="15">15 seconds</option>
                <option value="20">20 seconds</option>
              </select>
            </div>

            <!-- Aspect Ratio -->
            <div>
              <label for="video-aspect">Aspect Ratio</label>
              <select id="video-aspect" style="width: 100%; padding: 10px; border-radius: 10px; border: 1px solid var(--border-subtle); background: rgba(10, 12, 22, 0.9); color: var(--text-main);">
                <option value="720x1280" selected>9:16 Portrait (Reels)</option>
                <option value="1280x720">16:9 Landscape</option>
                <option value="1080x1080">1:1 Square</option>
                <option value="1024x1792">9:16 Tall Portrait</option>
              </select>
            </div>

            <!-- Scene Count -->
            <div>
              <label for="scene-count">Variations to Generate</label>
              <select id="scene-count" style="width: 100%; padding: 10px; border-radius: 10px; border: 1px solid var(--border-subtle); background: rgba(10, 12, 22, 0.9); color: var(--text-main);">
                <option value="1" selected>1 variation</option>
                <option value="2">2 variations</option>
                <option value="3">3 variations</option>
                <option value="5">5 variations</option>
              </select>
            </div>
          </div>
        </div>

        <!-- Voice Settings for Audio Consistency -->
        <div style="margin-top: 24px; padding-top: 20px; border-top: 1px solid var(--border-subtle);">
          <h3 style="margin: 0 0 16px; font-size: 1rem;">üéôÔ∏è Voice Settings (Audio Consistency)</h3>
          <p style="color: var(--text-muted); font-size: 0.85rem; margin-bottom: 16px;">
            Sora generates audio! Configure voice settings for consistent sound across all videos.
          </p>
          
          <div style="display: grid; gap: 16px;">
            <div>
              <label for="voice-description">Voice Description</label>
              <textarea id="voice-description" style="width: 100%; padding: 10px; border-radius: 10px; border: 1px solid var(--border-subtle); background: rgba(10, 12, 22, 0.9); color: var(--text-main); min-height: 80px; resize: vertical;" placeholder="Describe the character's voice...">Young adult female voice, playful and slightly sarcastic tone, American accent with Gen-Z inflections, speaks with expressive energy and occasional vocal fry, natural conversational cadence</textarea>
            </div>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px;">
              <div>
                <label for="voice-style">Speaking Style</label>
                <input type="text" id="voice-style" value="casual, relatable, meme-culture aware" style="width: 100%; padding: 10px; border-radius: 10px; border: 1px solid var(--border-subtle); background: rgba(10, 12, 22, 0.9); color: var(--text-main);" />
              </div>
              <div>
                <label for="voice-emotions">Emotional Expression</label>
                <input type="text" id="voice-emotions" value="expressive eye rolls, dramatic sighs, enthusiastic reactions" style="width: 100%; padding: 10px; border-radius: 10px; border: 1px solid var(--border-subtle); background: rgba(10, 12, 22, 0.9); color: var(--text-main);" />
              </div>
            </div>
            
            <div>
              <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                <input type="checkbox" id="include-voice" checked style="width: 18px; height: 18px;" />
                <span>Include voice instructions in all prompts (recommended for consistency)</span>
              </label>
            </div>
          </div>
        </div>

        <div class="btn-group">
          <button class="btn btn-secondary" id="back-to-step-1">‚Üê Back</button>
          <button class="btn btn-primary" id="next-to-step-3">Continue ‚Üí</button>
        </div>
      </div>

      <!-- Step 3: Topic/Story Input -->
      <div class="panel hidden" id="step-3">
        <h2>üí≠ What's Your Content About?</h2>
        <p style="color: var(--text-muted); margin-bottom: 16px;">
          Enter a topic or write out your full story/scenario.
        </p>

        <div style="margin-bottom: 20px;">
          <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px;">
            <input type="radio" name="input-mode" value="topic" checked />
            Quick Topic (AI suggests scenarios)
          </label>
          <label style="display: flex; align-items: center; gap: 8px;">
            <input type="radio" name="input-mode" value="story" />
            Full Story (AI breaks into scenes)
          </label>
        </div>

        <div id="topic-input-section">
          <label for="topic">Topic / Struggle</label>
          <textarea
            id="topic"
            placeholder='e.g., "Slack messages that start with quick question", "Micromanaging boss", "Boyfriend wants healthy food but I want fried chicken"'
          ></textarea>

          <button class="btn btn-primary" id="generate-scenarios-btn" style="margin-bottom: 20px;">
            üé¨ Generate Scenarios
          </button>

          <div id="scenarios-loading" class="loading hidden">üé® AI is brainstorming scenarios...</div>
          <div id="scenarios-error" class="error-text hidden"></div>
          <div id="scenarios-list" class="scenario-list"></div>
        </div>

        <div id="story-input-section" class="hidden">
          <label for="story">Full Story / Script</label>
          <textarea
            id="story"
            placeholder="Describe the full scenario with all the action and dialogue..."
            style="min-height: 150px;"
          ></textarea>

          <button class="btn btn-primary" id="generate-storyboard-btn" style="margin-bottom: 20px;">
            üé¨ Create Storyboard
          </button>

          <div id="storyboard-loading" class="loading hidden">üé® AI is creating storyboard...</div>
          <div id="storyboard-error" class="error-text hidden"></div>
          <div id="storyboard-list" class="scenario-list"></div>
        </div>

        <div class="btn-group">
          <button class="btn btn-secondary" id="back-to-step-2">‚Üê Back</button>
          <button class="btn btn-primary hidden" id="next-to-step-4">Generate Videos ‚Üí</button>
        </div>
      </div>

      <!-- Step 4: Review & Edit Prompts -->
      <div class="panel hidden" id="step-4">
        <h2>‚úèÔ∏è Review & Edit Sora Prompts</h2>
        <p style="color: var(--text-muted); margin-bottom: 16px;">
          Review the AI-generated prompts before sending to Sora. You can edit any prompt to fine-tune the output.
        </p>

        <!-- Prompt Snippets Panel -->
        <div style="margin-bottom: 20px; padding: 16px; background: rgba(91, 141, 255, 0.1); border-radius: 12px; border: 1px solid rgba(91, 141, 255, 0.2);">
          <h4 style="margin: 0 0 12px; font-size: 0.9rem; color: var(--accent);">üìù Quick Insert Snippets</h4>
          <div style="display: flex; flex-wrap: wrap; gap: 8px;" id="prompt-snippets">
            <button class="snippet-btn" data-snippet="Camera slowly dollies in on the subject, creating intimacy.">üì∑ Dolly In</button>
            <button class="snippet-btn" data-snippet="Camera pans left to right, revealing the scene.">üì∑ Pan Left‚ÜíRight</button>
            <button class="snippet-btn" data-snippet="Slow motion capture of the action, emphasizing dramatic effect.">üé¨ Slow Motion</button>
            <button class="snippet-btn" data-snippet="Quick cut between reactions, fast-paced editing style.">‚úÇÔ∏è Quick Cuts</button>
            <button class="snippet-btn" data-snippet="Soft, diffused natural lighting from a window.">üí° Soft Window Light</button>
            <button class="snippet-btn" data-snippet="Harsh fluorescent office lighting with slight green tint.">üí° Office Lighting</button>
            <button class="snippet-btn" data-snippet="Dramatic rim lighting creating silhouette effect.">üí° Dramatic Rim</button>
            <button class="snippet-btn" data-snippet="Character looks directly at camera, breaking the fourth wall.">üëÅÔ∏è Eye Contact</button>
            <button class="snippet-btn" data-snippet="Exaggerated eye roll with head tilt, expressing disbelief.">üôÑ Eye Roll</button>
            <button class="snippet-btn" data-snippet="Deep sigh with shoulder drop, showing exhaustion.">üòÆ‚Äçüí® Sigh</button>
            <button class="snippet-btn" data-snippet="Subtle smirk forming at corner of mouth.">üòè Smirk</button>
            <button class="snippet-btn" data-snippet="Modern minimalist apartment with plants and natural wood.">üè† Modern Apartment</button>
            <button class="snippet-btn" data-snippet="Busy open-plan office with cubicles and monitors.">üè¢ Office Cubicle</button>
            <button class="snippet-btn" data-snippet="Cozy coffee shop with warm ambient lighting.">‚òï Coffee Shop</button>
          </div>
          <p style="font-size: 0.75rem; color: var(--text-muted); margin-top: 8px;">
            üí° Click a snippet to copy, then paste into any prompt editor below
          </p>
        </div>

        <!-- A/B Generation Toggle -->
        <div style="margin-bottom: 16px; padding: 12px; background: rgba(52, 211, 153, 0.1); border-radius: 10px; border: 1px solid rgba(52, 211, 153, 0.3);">
          <label style="display: flex; align-items: center; gap: 10px; cursor: pointer; margin: 0;">
            <input type="checkbox" id="ab-generation" style="width: 18px; height: 18px;" />
            <span style="font-weight: 500;">üîÄ A/B Generation Mode</span>
            <span style="font-size: 0.8rem; color: var(--text-muted);">Generate 2 versions of each scene for comparison</span>
          </label>
        </div>

        <div id="prompt-review-list" class="scenario-list"></div>

        <div class="btn-group">
          <button class="btn btn-secondary" id="back-to-step-3-from-review">‚Üê Back</button>
          <button class="btn btn-primary" id="generate-preview-images">
            üçå Generate Preview Images ‚Üí
          </button>
        </div>
      </div>

      <!-- Step 5: Image Preview (Nano Banana) -->
      <div class="panel hidden" id="step-5">
        <h2>üçå Preview Images</h2>
        <p style="color: var(--text-muted); margin-bottom: 16px;">
          Review and refine still images before generating videos. This helps ensure character consistency.
        </p>

        <div id="image-gen-status" class="loading hidden"></div>
        <div id="image-gen-error" class="error-text hidden"></div>

        <!-- Image Generation Settings -->
        <div style="margin-bottom: 20px; padding: 16px; border-radius: 12px; background: rgba(255, 193, 7, 0.1); border: 1px solid rgba(255, 193, 7, 0.3);">
          <h4 style="margin: 0 0 12px; font-size: 0.9rem; color: #ffc107;">üçå Nano Banana Settings</h4>
          <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 12px;">
            <div>
              <label style="font-size: 0.75rem; color: var(--text-muted);">Model</label>
              <select id="nb-model" style="width: 100%; padding: 8px; border-radius: 8px; border: 1px solid var(--border-subtle); background: rgba(10,12,22,0.9); color: var(--text-main);">
                <option value="gemini-2.5-flash-image">‚ö° Fast (Gemini Flash)</option>
                <option value="gemini-3-pro-image-preview">üéØ Advanced (Gemini Pro)</option>
              </select>
            </div>
            <div>
              <label style="font-size: 0.75rem; color: var(--text-muted);">Resolution</label>
              <select id="nb-resolution" style="width: 100%; padding: 8px; border-radius: 8px; border: 1px solid var(--border-subtle); background: rgba(10,12,22,0.9); color: var(--text-main);">
                <option value="1K">1K (Fast)</option>
                <option value="2K" selected>2K (Balanced)</option>
                <option value="4K">4K (High Quality)</option>
              </select>
            </div>
            <div>
              <label style="font-size: 0.75rem; color: var(--text-muted);">Use Character Reference</label>
              <select id="nb-use-reference" style="width: 100%; padding: 8px; border-radius: 8px; border: 1px solid var(--border-subtle); background: rgba(10,12,22,0.9); color: var(--text-main);">
                <option value="yes" selected>Yes - Use character image</option>
                <option value="no">No - Text only</option>
              </select>
            </div>
          </div>
        </div>

        <!-- Preview Images Grid -->
        <div id="preview-images-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 16px; margin-bottom: 20px;">
          <!-- Images will be added here -->
        </div>

        <!-- Nano Banana Status -->
        <div id="nb-status-panel" class="hidden" style="margin-bottom: 20px; padding: 16px; border-radius: 12px; background: rgba(91, 141, 255, 0.1); border: 1px solid rgba(91, 141, 255, 0.3);">
          <div style="display: flex; align-items: center; gap: 12px;">
            <div id="nb-spinner" style="width: 24px; height: 24px; border: 3px solid var(--accent-soft); border-top-color: var(--accent); border-radius: 50%; animation: spin 1s linear infinite;"></div>
            <div>
              <div id="nb-status-text" style="font-weight: 600;">Generating images...</div>
              <div id="nb-progress-text" style="font-size: 0.8rem; color: var(--text-muted);">0 of 0 scenes</div>
            </div>
          </div>
        </div>

        <div class="btn-group">
          <button class="btn btn-secondary" id="back-to-step-4-from-preview">‚Üê Back to Prompts</button>
          <button class="btn btn-secondary" id="regenerate-all-images" disabled>
            üîÑ Regenerate All Images
          </button>
          <button class="btn btn-primary" id="approve-images-generate-videos" disabled>
            ‚úì Approve & Generate Videos ‚Üí
          </button>
        </div>
      </div>

      <!-- Step 6: Video Generation -->
      <div class="panel hidden" id="step-6">
        <h2>üé• Generate Videos</h2>
        <p style="color: var(--text-muted); margin-bottom: 16px;">
          Videos will be generated one by one. You can remix any scene before final export.
        </p>

        <div id="generation-status" class="loading hidden"></div>
        <div id="generation-error" class="error-text hidden"></div>

        <div class="video-grid" id="video-grid"></div>

        <div class="btn-group">
          <button class="btn btn-secondary" id="back-to-step-5">‚Üê Back to Images</button>
        </div>
      </div>
    </div>

    <!-- Custom Preset Modal -->
    <div id="preset-modal" class="hidden" style="
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 2000;
    ">
      <div style="
        background: var(--panel);
        border: 1px solid var(--border-subtle);
        border-radius: 20px;
        padding: 24px;
        max-width: 500px;
        width: 90%;
        max-height: 90vh;
        overflow-y: auto;
      ">
        <h2 style="margin: 0 0 16px;">‚ú® Create Custom Personality</h2>
        <form id="preset-form">
          <div style="margin-bottom: 16px;">
            <label>Preset Name</label>
            <input type="text" id="preset-name" placeholder="My Custom Style" required style="width: 100%; padding: 10px; border-radius: 10px; border: 1px solid var(--border-subtle); background: rgba(10,12,22,0.9); color: var(--text-main);" />
          </div>
          <div style="margin-bottom: 16px;">
            <label>Description</label>
            <input type="text" id="preset-description" placeholder="Short description" style="width: 100%; padding: 10px; border-radius: 10px; border: 1px solid var(--border-subtle); background: rgba(10,12,22,0.9); color: var(--text-main);" />
          </div>
          <div style="margin-bottom: 16px;">
            <label>Tone</label>
            <input type="text" id="preset-tone" placeholder="playful, sarcastic, dramatic" style="width: 100%; padding: 10px; border-radius: 10px; border: 1px solid var(--border-subtle); background: rgba(10,12,22,0.9); color: var(--text-main);" />
          </div>
          <div style="margin-bottom: 16px;">
            <label>Humor Style</label>
            <input type="text" id="preset-humor" placeholder="self-deprecating, observational" style="width: 100%; padding: 10px; border-radius: 10px; border: 1px solid var(--border-subtle); background: rgba(10,12,22,0.9); color: var(--text-main);" />
          </div>
          <div style="margin-bottom: 16px;">
            <label>Caption Style</label>
            <input type="text" id="preset-caption" placeholder="short punchy hooks, relatable statements" style="width: 100%; padding: 10px; border-radius: 10px; border: 1px solid var(--border-subtle); background: rgba(10,12,22,0.9); color: var(--text-main);" />
          </div>
          <div style="margin-bottom: 20px;">
            <label>Emoji Usage</label>
            <select id="preset-emoji" style="width: 100%; padding: 10px; border-radius: 10px; border: 1px solid var(--border-subtle); background: rgba(10,12,22,0.9); color: var(--text-main);">
              <option value="heavy">Heavy - lots of emojis üòÇüî•üíÄ</option>
              <option value="moderate" selected>Moderate - occasional emojis</option>
              <option value="minimal">Minimal - rarely use emojis</option>
              <option value="none">None - no emojis</option>
            </select>
          </div>
          <div style="display: flex; gap: 12px;">
            <button type="button" onclick="closePresetModal()" style="flex: 1; padding: 12px; border-radius: 10px; border: 1px solid var(--border-subtle); background: transparent; color: var(--text-muted); cursor: pointer;">
              Cancel
            </button>
            <button type="submit" style="flex: 1; padding: 12px; border-radius: 10px; border: none; background: linear-gradient(135deg, var(--accent), #bf5af2); color: white; cursor: pointer; font-weight: 600;">
              Save Preset
            </button>
          </div>
        </form>
      </div>
    </div>

    <script>
      // State
      let characterProfile = null;
      let characterImageFile = null; // Store the character image for reuse
      let savedCharacters = []; // Loaded from database
      let selectedPersonality = 'genz-meme';
      let scenarios = [];
      let currentStep = 1;

      // Video Settings (from Step 2)
      let videoSettings = {
        duration: 8,
        aspectRatio: '720x1280',
        sceneCount: 1
      };

      // Build voice prompt suffix for consistency (reads from UI fields)
      function getVoicePromptSuffix() {
        const includeVoice = document.getElementById('include-voice')?.checked ?? true;
        if (!includeVoice) return '';

        const voiceDesc = document.getElementById('voice-description')?.value || 
          "Young adult female voice, playful and slightly sarcastic tone, American accent with Gen-Z inflections";
        const voiceStyle = document.getElementById('voice-style')?.value || 
          "casual, relatable, meme-culture aware";
        const voiceEmotions = document.getElementById('voice-emotions')?.value || 
          "expressive eye rolls, dramatic sighs, enthusiastic reactions";

        return `

AUDIO/VOICE REQUIREMENTS (CRITICAL - Keep consistent across ALL generations):
- Voice: ${voiceDesc}
- Speaking style: ${voiceStyle}
- Emotional expression: ${voiceEmotions}
- Background audio: Subtle ambient sounds matching the setting (office hum, cafe chatter, etc.)
- No background music unless explicitly specified in the scene.`;
      }

      // Get current voice settings as object (for saving)
      function getVoiceSettings() {
        return {
          description: document.getElementById('voice-description')?.value || '',
          style: document.getElementById('voice-style')?.value || '',
          emotions: document.getElementById('voice-emotions')?.value || '',
          enabled: document.getElementById('include-voice')?.checked ?? true
        };
      }

      // Elements
      const wizardSteps = document.querySelectorAll('.wizard-step');
      const stepPanels = [
        null,
        document.getElementById('step-1'),
        document.getElementById('step-2'),
        document.getElementById('step-3'),
        document.getElementById('step-4'),
        document.getElementById('step-5')
      ];

      // ==========================================
      // INITIALIZE - Load saved characters
      // ==========================================
      document.addEventListener('DOMContentLoaded', async () => {
        await loadSavedCharacters();
        
        // Check if coming from Characters page with a selected character
        const selectedCharId = localStorage.getItem('selectedCharacterId');
        if (selectedCharId) {
          const charSelect = document.getElementById('saved-character-select');
          charSelect.value = selectedCharId;
          handleSavedCharacterSelect();
          localStorage.removeItem('selectedCharacterId');
        }

        // Check if coming from Templates page with a topic
        const templateTopic = localStorage.getItem('templateTopic');
        if (templateTopic) {
          document.getElementById('topic').value = templateTopic;
          localStorage.removeItem('templateTopic');
        }
      });

      async function loadSavedCharacters() {
        try {
          const res = await fetch('/api/characters');
          savedCharacters = await res.json();
          
          const select = document.getElementById('saved-character-select');
          select.innerHTML = '<option value="">-- Upload New Character --</option>';
          
          savedCharacters.forEach(char => {
            const option = document.createElement('option');
            option.value = char.id;
            option.textContent = char.name;
            select.appendChild(option);
          });
        } catch (err) {
          console.error('Failed to load saved characters:', err);
        }
      }

      // Handle saved character selection
      document.getElementById('saved-character-select').addEventListener('change', handleSavedCharacterSelect);
      
      // Continue button for saved character - use event delegation to ensure it works
      document.addEventListener('click', (e) => {
        if (e.target && e.target.id === 'continue-with-saved-char') {
          console.log('Continue button clicked, characterProfile:', characterProfile);
          if (characterProfile) {
            goToStep(2);
            loadPersonalityPresets();
          } else {
            alert('Please select a character first');
          }
        }
      });

      function handleSavedCharacterSelect() {
        const select = document.getElementById('saved-character-select');
        const charId = select.value;
        const preview = document.getElementById('saved-character-preview');
        const uploadSection = document.getElementById('upload-new-character-section');

        console.log('Character selected:', charId, 'Available characters:', savedCharacters);

        if (charId) {
          // Use loose comparison to handle string/number ID mismatches
          const char = savedCharacters.find(c => String(c.id) === String(charId));
          console.log('Found character:', char);
          
          if (char) {
            let styleGuide;
            try {
              styleGuide = typeof char.style_guide === 'string' 
                ? JSON.parse(char.style_guide) 
                : char.style_guide;
            } catch (e) {
              console.warn('Could not parse style guide:', e);
              styleGuide = {};
            }

            // Set character profile
            characterProfile = {
              id: char.id,
              name: char.name,
              styleGuide: styleGuide,
              imageUrl: char.image_url
            };
            
            console.log('Character profile set:', characterProfile);

            // Show preview
            document.getElementById('selected-char-name').textContent = char.name;
            document.getElementById('selected-char-style').textContent = 
              styleGuide?.character?.visualStyle || 'Style analyzed';
            
            // Show image if available
            const charImage = document.getElementById('selected-char-image');
            const charEmoji = document.getElementById('selected-char-emoji');
            if (char.image_url) {
              charImage.src = char.image_url;
              charImage.style.display = 'block';
              charEmoji.style.display = 'none';
            } else {
              charImage.style.display = 'none';
              charEmoji.style.display = 'block';
            }
            
            preview.classList.remove('hidden');
            
            // Hide upload section
            uploadSection.style.display = 'none';
          } else {
            console.error('Character not found in savedCharacters array');
          }
        } else {
          // Show upload section, hide preview
          preview.classList.add('hidden');
          uploadSection.style.display = 'block';
          characterProfile = null;
        }
      }

      // Wizard Navigation
      function goToStep(step) {
        currentStep = step;
        wizardSteps.forEach((el, idx) => {
          el.classList.remove('active');
          if (idx + 1 < step) el.classList.add('completed');
          else el.classList.remove('completed');
          if (idx + 1 === step) el.classList.add('active');
        });

        stepPanels.forEach((panel, idx) => {
          if (panel) {
            panel.classList.toggle('hidden', idx !== step);
          }
        });

        // Update video settings when leaving Step 2
        if (step > 2) {
          videoSettings.duration = parseInt(document.getElementById('video-duration').value);
          videoSettings.aspectRatio = document.getElementById('video-aspect').value;
          videoSettings.sceneCount = parseInt(document.getElementById('scene-count').value);
        }
      }

      // Step 1: Character Upload & Analysis
      const characterUploadZone = document.getElementById('character-upload-zone');
      const characterImageInput = document.getElementById('character-image');
      const characterPreview = document.getElementById('character-preview');
      const characterForm = document.getElementById('character-form');
      const characterLoading = document.getElementById('character-loading');
      const characterError = document.getElementById('character-error');
      const styleGuidePreview = document.getElementById('style-guide-preview');
      const styleGuideJson = document.getElementById('style-guide-json');

      characterUploadZone.addEventListener('click', () => characterImageInput.click());
      characterImageInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) {
          characterImageFile = file; // Store for later use
          const reader = new FileReader();
          reader.onload = (e) => {
            characterPreview.src = e.target.result;
            characterPreview.classList.remove('hidden');
            characterUploadZone.classList.add('has-file');
          };
          reader.readAsDataURL(file);
        }
      });

      characterForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        const file = characterImageInput.files[0];
        const name = document.getElementById('character-name').value;

        if (!file) {
          characterError.textContent = 'Please upload a character image';
          characterError.classList.remove('hidden');
          return;
        }

        characterError.classList.add('hidden');
        characterLoading.classList.remove('hidden');
        document.getElementById('analyze-btn').disabled = true;

        try {
          const formData = new FormData();
          formData.append('image', file);
          formData.append('characterName', name);

          const res = await fetch('/api/characters/analyze', {
            method: 'POST',
            body: formData
          });

          if (!res.ok) {
            throw new Error('Failed to analyze character');
          }

          characterProfile = await res.json();
          styleGuideJson.textContent = JSON.stringify(characterProfile.styleGuide, null, 2);
          styleGuidePreview.classList.remove('hidden');
          
          // Populate visual style guide editor
          populateStyleGuideEditor(characterProfile.styleGuide);

          // AUTO-SAVE character to database
          try {
            await fetch('/api/characters/save', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                id: characterProfile.id,
                name: characterProfile.name,
                styleGuide: characterProfile.styleGuide,
                imageUrl: null
              })
            });
            console.log('‚úÖ Character auto-saved to database');
            // Refresh the saved characters dropdown
            await loadSavedCharacters();
          } catch (saveErr) {
            console.warn('Could not auto-save character:', saveErr);
          }

          // Auto-advance after 2 seconds
          setTimeout(() => {
            goToStep(2);
            loadPersonalityPresets();
          }, 2000);
        } catch (err) {
          characterError.textContent = err.message;
          characterError.classList.remove('hidden');
        } finally {
          characterLoading.classList.add('hidden');
          document.getElementById('analyze-btn').disabled = false;
        }
      });

      // Visual Style Guide Editor Functions
      let styleColors = [];

      function populateStyleGuideEditor(styleGuide) {
        if (!styleGuide) return;
        
        const char = styleGuide.character || {};
        
        // Populate fields
        document.getElementById('style-appearance').value = char.appearance || '';
        document.getElementById('style-visual').value = char.visualStyle || '';
        document.getElementById('style-artistic').value = char.artisticStyle || '';
        document.getElementById('style-lighting').value = char.lighting || '';
        document.getElementById('style-details').value = char.details || '';
        
        // Populate color swatches
        styleColors = char.colorPalette || [];
        renderColorSwatches();
      }

      function renderColorSwatches() {
        const container = document.getElementById('color-swatches');
        container.innerHTML = styleColors.map((color, idx) => `
          <div style="display: flex; align-items: center; gap: 4px; padding: 4px 8px; background: rgba(0,0,0,0.3); border-radius: 8px;">
            <div style="width: 24px; height: 24px; border-radius: 6px; background: ${color}; border: 2px solid rgba(255,255,255,0.2);"></div>
            <span style="font-size: 0.75rem; font-family: monospace;">${color}</span>
            <button onclick="removeColorSwatch(${idx})" style="background: none; border: none; color: var(--danger); cursor: pointer; padding: 2px;">√ó</button>
          </div>
        `).join('');
      }

      window.addColorSwatch = function() {
        const input = document.getElementById('new-color');
        let color = input.value.trim();
        if (!color) return;
        
        // Add # if missing
        if (!color.startsWith('#')) color = '#' + color;
        
        // Validate hex color
        if (!/^#[0-9A-Fa-f]{6}$/.test(color)) {
          alert('Please enter a valid hex color (e.g., #8BC34A)');
          return;
        }
        
        styleColors.push(color);
        renderColorSwatches();
        updateStyleGuideFromEditor();
        input.value = '';
      };

      window.removeColorSwatch = function(idx) {
        styleColors.splice(idx, 1);
        renderColorSwatches();
        updateStyleGuideFromEditor();
      };

      function updateStyleGuideFromEditor() {
        if (!characterProfile) return;
        
        characterProfile.styleGuide = characterProfile.styleGuide || {};
        characterProfile.styleGuide.character = characterProfile.styleGuide.character || {};
        
        const char = characterProfile.styleGuide.character;
        char.appearance = document.getElementById('style-appearance').value;
        char.visualStyle = document.getElementById('style-visual').value;
        char.artisticStyle = document.getElementById('style-artistic').value;
        char.lighting = document.getElementById('style-lighting').value;
        char.details = document.getElementById('style-details').value;
        char.colorPalette = styleColors;
        
        // Update JSON view
        document.getElementById('style-guide-json').textContent = JSON.stringify(characterProfile.styleGuide, null, 2);
      }

      // Add change listeners to style inputs
      ['style-appearance', 'style-visual', 'style-artistic', 'style-lighting', 'style-details'].forEach(id => {
        document.getElementById(id)?.addEventListener('change', updateStyleGuideFromEditor);
      });

      window.toggleRawJson = function() {
        const json = document.getElementById('style-guide-json');
        json.classList.toggle('hidden');
      };

      // Step 2: Personality Presets
      let customPresets = [];

      async function loadPersonalityPresets() {
        try {
          // Load default presets
          const res = await fetch('/api/personalities/presets');
          const presets = await res.json();

          const grid = document.getElementById('personality-presets');
          grid.innerHTML = '';

          Object.entries(presets).forEach(([key, preset]) => {
            const card = document.createElement('div');
            card.className = 'preset-card';
            if (key === selectedPersonality) card.classList.add('selected');
            card.innerHTML = `
              <h3>${key.split('-').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ')}</h3>
              <p>${preset.description}</p>
            `;
            card.addEventListener('click', () => {
              selectedPersonality = key;
              document.querySelectorAll('.preset-card').forEach(c => c.classList.remove('selected'));
              card.classList.add('selected');
            });
            grid.appendChild(card);
          });

          // Load custom presets
          await loadCustomPresets();
        } catch (err) {
          console.error('Failed to load presets:', err);
        }
      }

      async function loadCustomPresets() {
        try {
          const res = await fetch('/api/personalities/custom');
          customPresets = await res.json();
          
          const section = document.getElementById('custom-presets-section');
          const grid = document.getElementById('custom-presets');
          
          if (customPresets.length === 0) {
            section.classList.add('hidden');
            return;
          }
          
          section.classList.remove('hidden');
          grid.innerHTML = '';
          
          customPresets.forEach(preset => {
            const card = document.createElement('div');
            card.className = 'preset-card';
            if (preset.id === selectedPersonality) card.classList.add('selected');
            card.innerHTML = `
              <h3>${preset.name} <span style="font-size: 0.7rem; color: var(--accent-green);">‚òÖ Custom</span></h3>
              <p>${preset.description || 'Custom personality preset'}</p>
              <button onclick="event.stopPropagation(); deleteCustomPreset('${preset.id}')" style="
                margin-top: 8px;
                padding: 4px 8px;
                font-size: 0.7rem;
                border-radius: 4px;
                border: 1px solid var(--danger);
                background: transparent;
                color: var(--danger);
                cursor: pointer;
              ">Delete</button>
            `;
            card.addEventListener('click', () => {
              selectedPersonality = preset.id;
              document.querySelectorAll('.preset-card').forEach(c => c.classList.remove('selected'));
              card.classList.add('selected');
            });
            grid.appendChild(card);
          });
        } catch (err) {
          console.error('Failed to load custom presets:', err);
        }
      }

      window.openCreatePresetModal = function() {
        document.getElementById('preset-modal').classList.remove('hidden');
        document.getElementById('preset-modal').style.display = 'flex';
      };

      window.closePresetModal = function() {
        document.getElementById('preset-modal').classList.add('hidden');
        document.getElementById('preset-modal').style.display = 'none';
        document.getElementById('preset-form').reset();
      };

      document.getElementById('preset-form').addEventListener('submit', async (e) => {
        e.preventDefault();
        
        const preset = {
          id: 'custom_' + Date.now(),
          name: document.getElementById('preset-name').value,
          description: document.getElementById('preset-description').value,
          tone: document.getElementById('preset-tone').value,
          humorStyle: document.getElementById('preset-humor').value,
          captionStyle: document.getElementById('preset-caption').value,
          emojiUsage: document.getElementById('preset-emoji').value
        };

        try {
          await fetch('/api/personalities/custom/save', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(preset)
          });
          
          closePresetModal();
          await loadCustomPresets();
          
          // Select the new preset
          selectedPersonality = preset.id;
          document.querySelectorAll('.preset-card').forEach(c => c.classList.remove('selected'));
          
        } catch (err) {
          console.error('Failed to save preset:', err);
          alert('Failed to save preset');
        }
      });

      window.deleteCustomPreset = async function(id) {
        if (!confirm('Delete this custom preset?')) return;
        
        try {
          await fetch(`/api/personalities/custom/${id}`, { method: 'DELETE' });
          await loadCustomPresets();
          
          // Reset selection if deleted preset was selected
          if (selectedPersonality === id) {
            selectedPersonality = 'genz-meme';
          }
        } catch (err) {
          console.error('Failed to delete preset:', err);
        }
      };

      document.getElementById('back-to-step-1').addEventListener('click', () => goToStep(1));
      document.getElementById('next-to-step-3').addEventListener('click', () => goToStep(3));

      // Step 3: Topic/Story Input
      const inputModeRadios = document.querySelectorAll('input[name="input-mode"]');
      const topicSection = document.getElementById('topic-input-section');
      const storySection = document.getElementById('story-input-section');

      inputModeRadios.forEach(radio => {
        radio.addEventListener('change', (e) => {
          if (e.target.value === 'topic') {
            topicSection.classList.remove('hidden');
            storySection.classList.add('hidden');
          } else {
            topicSection.classList.add('hidden');
            storySection.classList.remove('hidden');
          }
        });
      });

      // Generate Scenarios from Topic
      document.getElementById('generate-scenarios-btn').addEventListener('click', async () => {
        const topic = document.getElementById('topic').value.trim();
        if (!topic) {
          alert('Please enter a topic');
          return;
        }

        const loading = document.getElementById('scenarios-loading');
        const error = document.getElementById('scenarios-error');
        const list = document.getElementById('scenarios-list');

        loading.classList.remove('hidden');
        error.classList.add('hidden');
        list.innerHTML = '';

        try {
          const res = await fetch('/api/scenarios/generate', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              topic,
              characterStyleGuide: characterProfile.styleGuide,
              personalityPreset: selectedPersonality,
              sceneCount: videoSettings.sceneCount
            })
          });

          if (!res.ok) throw new Error('Failed to generate scenarios');

          const result = await res.json();
          scenarios = result.scenarios || [result];

          renderScenarios(scenarios, list);
          document.getElementById('next-to-step-4').classList.remove('hidden');

          // AUTO-SAVE PROJECT TO DATABASE
          try {
            const projectId = 'proj_' + Date.now();
            await fetch('/api/projects/save', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                id: projectId,
                characterId: characterProfile?.id || null,
                topic: topic,
                personalityPreset: selectedPersonality,
                scenarios: scenarios
              })
            });
            // Store project ID for later use
            window.currentProjectId = projectId;
            console.log('‚úÖ Project saved:', projectId);
          } catch (saveErr) {
            console.warn('Could not save project:', saveErr);
          }
        } catch (err) {
          error.textContent = err.message;
          error.classList.remove('hidden');
        } finally {
          loading.classList.add('hidden');
        }
      });

      // Generate Storyboard from Story
      document.getElementById('generate-storyboard-btn').addEventListener('click', async () => {
        const story = document.getElementById('story').value.trim();
        if (!story) {
          alert('Please enter a story');
          return;
        }

        const loading = document.getElementById('storyboard-loading');
        const error = document.getElementById('storyboard-error');
        const list = document.getElementById('storyboard-list');

        loading.classList.remove('hidden');
        error.classList.add('hidden');
        list.innerHTML = '';

        try {
          const res = await fetch('/api/storyboard', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              story,
              characterStyleGuide: characterProfile.styleGuide,
              personalityPreset: selectedPersonality,
              targetDuration: 15
            })
          });

          if (!res.ok) throw new Error('Failed to generate storyboard');

          const result = await res.json();
          scenarios = result.scenes || [];

          renderScenarios(scenarios, list);
          document.getElementById('next-to-step-4').classList.remove('hidden');
        } catch (err) {
          error.textContent = err.message;
          error.classList.remove('hidden');
        } finally {
          loading.classList.add('hidden');
        }
      });

      function renderScenarios(scenes, container) {
        container.innerHTML = '';
        scenes.forEach((scene, idx) => {
          const card = document.createElement('div');
          card.className = 'scenario-card';
          card.innerHTML = `
            <h3>${scene.hook || scene.description || `Scene ${idx + 1}`}</h3>
            <div class="meta">${scene.duration || 8}s ¬∑ ${scene.textOverlay || 'No text overlay'}</div>
            ${scene.dialogue ? `<div class="dialogue">"${scene.dialogue}"</div>` : ''}
            <div class="prompt">${scene.prompt || scene.sceneDescription || ''}</div>
          `;
          container.appendChild(card);
        });
      }

      document.getElementById('back-to-step-2').addEventListener('click', () => goToStep(2));
      document.getElementById('next-to-step-4').addEventListener('click', () => {
        goToStep(4);
        renderPromptReview();
      });

      // Step 4: Prompt Review
      document.getElementById('back-to-step-3-from-review').addEventListener('click', () => goToStep(3));
      document.getElementById('generate-preview-images').addEventListener('click', () => {
        goToStep(5);
        startImagePreviewGeneration();
      });

      // Snippet copy functionality
      document.querySelectorAll('.snippet-btn').forEach(btn => {
        btn.addEventListener('click', async () => {
          const snippet = btn.dataset.snippet;
          try {
            await navigator.clipboard.writeText(snippet);
            btn.classList.add('copied');
            const originalText = btn.textContent;
            btn.textContent = '‚úì Copied!';
            setTimeout(() => {
              btn.classList.remove('copied');
              btn.textContent = originalText;
            }, 1500);
          } catch (err) {
            console.error('Failed to copy:', err);
          }
        });
      });

      // Copy prompt to clipboard function
      async function copyPromptToClipboard(idx) {
        const prompt = scenarios[idx]?.prompt || scenarios[idx]?.sceneDescription || '';
        try {
          await navigator.clipboard.writeText(prompt + getVoicePromptSuffix());
          const btn = document.querySelector(`[data-copy-idx="${idx}"]`);
          if (btn) {
            btn.classList.add('copied');
            btn.textContent = '‚úì Copied!';
            setTimeout(() => {
              btn.classList.remove('copied');
              btn.textContent = 'üìã Copy';
            }, 1500);
          }
        } catch (err) {
          console.error('Failed to copy:', err);
          alert('Failed to copy to clipboard');
        }
      }

      // Delete scenario function
      function deleteScenario(idx) {
        if (confirm('Delete this scenario?')) {
          scenarios.splice(idx, 1);
          renderPromptReview();
          if (scenarios.length === 0) {
            document.getElementById('next-to-step-4').classList.add('hidden');
          }
        }
      }

      // Move scenario up/down
      function moveScenario(idx, direction) {
        const newIdx = idx + direction;
        if (newIdx < 0 || newIdx >= scenarios.length) return;
        
        const temp = scenarios[idx];
        scenarios[idx] = scenarios[newIdx];
        scenarios[newIdx] = temp;
        renderPromptReview();
      }

      // Regenerate single scenario
      async function regenerateScenario(idx) {
        const topic = document.getElementById('topic').value.trim();
        if (!topic) {
          alert('Original topic not found');
          return;
        }

        const card = document.querySelector(`#prompt-review-card-${idx}`);
        if (card) {
          card.style.opacity = '0.5';
          card.innerHTML = '<div class="loading">üîÑ Regenerating scenario...</div>';
        }

        try {
          const res = await fetch('/api/scenarios/generate', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              topic: topic + ' (alternative take)',
              characterStyleGuide: characterProfile?.styleGuide,
              personalityPreset: selectedPersonality,
              sceneCount: 1
            })
          });

          if (!res.ok) throw new Error('Failed to regenerate');

          const result = await res.json();
          const newScenario = result.scenarios?.[0] || result;
          scenarios[idx] = newScenario;
          renderPromptReview();
        } catch (err) {
          console.error('Regenerate error:', err);
          alert('Failed to regenerate scenario');
          renderPromptReview();
        }
      }

      // Save prompt to library
      async function savePromptToLibrary(idx) {
        const scene = scenarios[idx];
        const name = prompt('Name for this prompt template:', scene.hook || 'My Prompt');
        if (!name) return;

        try {
          await fetch('/api/prompts/library/save', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              id: 'prompt_' + Date.now(),
              name: name,
              category: selectedPersonality,
              structuredPrompt: scene,
              textPrompt: scene.prompt || scene.sceneDescription,
              tags: [selectedPersonality, 'saved']
            })
          });
          alert('‚úì Prompt saved to library!');
        } catch (err) {
          console.error('Save prompt error:', err);
          alert('Failed to save prompt');
        }
      }

      function renderPromptReview() {
        const container = document.getElementById('prompt-review-list');
        container.innerHTML = '';

        scenarios.forEach((scene, idx) => {
          const card = document.createElement('div');
          card.className = 'prompt-review-card';
          card.id = `prompt-review-card-${idx}`;
          
          const isExpanded = idx === 0; // First one expanded by default
          
          card.innerHTML = `
            <h3 style="display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; gap: 8px;">
              <span>Scene ${idx + 1}: ${scene.hook || scene.description || 'Untitled'}</span>
              <div style="display: flex; align-items: center; gap: 8px;">
                <button class="copy-btn" data-copy-idx="${idx}" onclick="copyPromptToClipboard(${idx})">üìã Copy</button>
              <span class="expand-toggle" data-idx="${idx}">
                ${isExpanded ? '‚ñº Collapse' : '‚ñ∂ Expand'}
              </span>
              </div>
            </h3>
            
            <!-- TEXT OVERLAY EDITOR -->
            <div style="margin-bottom: 12px; padding: 12px; background: rgba(91, 141, 255, 0.1); border-radius: 8px; border: 1px solid rgba(91, 141, 255, 0.2);">
              <label style="display: block; font-size: 0.8rem; color: var(--accent); margin-bottom: 6px;">
                üìù Text Overlay (Caption)
              </label>
              <input 
                type="text" 
                class="text-overlay-input"
                data-idx="${idx}"
                value="${scene.textOverlay || ''}"
                placeholder="Add caption text that appears on screen..."
                style="width: 100%; padding: 8px 10px; border-radius: 8px; border: 1px solid var(--border-subtle); background: rgba(10, 12, 22, 0.9); color: var(--text-main); font-size: 0.9rem;"
              />
              <div style="font-size: 0.7rem; color: var(--text-muted); margin-top: 4px;">
                üí° This text will be included in the AI prompt for on-screen display
              </div>
            </div>
            
            <div class="meta-info">
              <div class="meta-item">
                <strong>Duration</strong>
                ${videoSettings.duration} seconds
              </div>
              ${scene.dialogue ? `
                <div class="meta-item">
                  <strong>Dialogue</strong>
                  "${scene.dialogue}"
                </div>
              ` : ''}
                <div class="meta-item">
                <strong>Voice</strong>
                ${document.getElementById('include-voice')?.checked ? 'üéôÔ∏è Included' : 'üîá Disabled'}
                </div>
            </div>

            <div class="prompt-section" id="prompt-section-${idx}" style="display: ${isExpanded ? 'block' : 'none'};">
              <label style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px; color: var(--text-muted); font-size: 0.85rem;">
                <strong>Sora Prompt</strong> (Edit if needed)
                <span style="font-size: 0.7rem;">${(scene.prompt || scene.sceneDescription || '').length} chars</span>
              </label>
              <textarea 
                class="prompt-editor" 
                data-idx="${idx}"
                placeholder="Full Sora prompt..."
              >${scene.prompt || scene.sceneDescription || ''}</textarea>
              
              <!-- Prompt Breakdown -->
              <div style="margin-top: 12px; padding: 12px; background: rgba(0,0,0,0.3); border-radius: 8px;">
                <div style="font-size: 0.8rem; font-weight: 600; margin-bottom: 8px; color: var(--accent);">üìä Prompt Breakdown</div>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 8px; font-size: 0.75rem;">
                  <div style="padding: 6px; background: rgba(91, 141, 255, 0.1); border-radius: 6px;">
                    <div style="color: var(--text-muted);">üì∑ Camera</div>
                    <div>${scene.cameraMovement || scene.photography?.camera || 'Standard'}</div>
                  </div>
                  <div style="padding: 6px; background: rgba(91, 141, 255, 0.1); border-radius: 6px;">
                    <div style="color: var(--text-muted);">üí° Lighting</div>
                    <div>${scene.lighting || scene.photography?.lighting || 'Natural'}</div>
                  </div>
                  <div style="padding: 6px; background: rgba(91, 141, 255, 0.1); border-radius: 6px;">
                    <div style="color: var(--text-muted);">üé≠ Action</div>
                    <div>${scene.action || scene.characterAction || 'Expressive'}</div>
                  </div>
                  <div style="padding: 6px; background: rgba(91, 141, 255, 0.1); border-radius: 6px;">
                    <div style="color: var(--text-muted);">üåç Setting</div>
                    <div>${scene.setting || scene.background?.setting || 'Interior'}</div>
                  </div>
                </div>
              </div>
              
              <div style="margin-top: 8px; font-size: 0.75rem; color: var(--text-muted);">
                üí° Tip: Be specific about camera angles, lighting, and character details for best results
              </div>
            </div>

            <!-- Scenario Actions -->
            <div class="scenario-actions">
              <button class="scenario-action-btn" onclick="moveScenario(${idx}, -1)" ${idx === 0 ? 'disabled style="opacity:0.3"' : ''}>‚¨ÜÔ∏è Move Up</button>
              <button class="scenario-action-btn" onclick="moveScenario(${idx}, 1)" ${idx === scenarios.length - 1 ? 'disabled style="opacity:0.3"' : ''}>‚¨áÔ∏è Move Down</button>
              <button class="scenario-action-btn" onclick="regenerateScenario(${idx})">üîÑ Regenerate</button>
              <button class="scenario-action-btn" onclick="savePromptToLibrary(${idx})">üíæ Save to Library</button>
              <button class="scenario-action-btn delete" onclick="deleteScenario(${idx})">üóëÔ∏è Delete</button>
            </div>
          `;
          
          container.appendChild(card);
        });

        // Add expand/collapse handlers
        document.querySelectorAll('.expand-toggle').forEach(toggle => {
          toggle.addEventListener('click', (e) => {
            const idx = e.target.dataset.idx;
            const section = document.getElementById(`prompt-section-${idx}`);
            const isVisible = section.style.display !== 'none';
            
            section.style.display = isVisible ? 'none' : 'block';
            e.target.textContent = isVisible ? '‚ñ∂ Expand' : '‚ñº Collapse';
          });
        });

        // Update scenarios when prompts are edited
        document.querySelectorAll('.prompt-editor').forEach(editor => {
          editor.addEventListener('input', (e) => {
            const idx = parseInt(e.target.dataset.idx);
            scenarios[idx].prompt = e.target.value;
            // Update char count
            const label = e.target.previousElementSibling?.querySelector('span');
            if (label) label.textContent = e.target.value.length + ' chars';
          });
        });

        // Update text overlays when edited
        document.querySelectorAll('.text-overlay-input').forEach(input => {
          input.addEventListener('change', (e) => {
            const idx = parseInt(e.target.dataset.idx);
            scenarios[idx].textOverlay = e.target.value;
            
            // Also update the prompt to include text overlay instruction
            if (e.target.value) {
              const promptEditor = document.querySelector(`.prompt-editor[data-idx="${idx}"]`);
              if (promptEditor && !promptEditor.value.includes('TEXT ON SCREEN:')) {
                promptEditor.value += `\n\nTEXT ON SCREEN: "${e.target.value}" - Display this text prominently in the video.`;
                scenarios[idx].prompt = promptEditor.value;
              }
            }
          });
        });
      }

      // Step 5: Image Preview (Nano Banana)
      let previewImages = []; // Store generated preview images
      
      document.getElementById('back-to-step-4-from-preview').addEventListener('click', () => goToStep(4));
      document.getElementById('regenerate-all-images').addEventListener('click', () => startImagePreviewGeneration());
      document.getElementById('approve-images-generate-videos').addEventListener('click', () => {
        goToStep(6);
        startVideoGeneration();
      });

      async function startImagePreviewGeneration() {
        const grid = document.getElementById('preview-images-grid');
        const status = document.getElementById('nb-status-panel');
        const statusText = document.getElementById('nb-status-text');
        const progressText = document.getElementById('nb-progress-text');
        const error = document.getElementById('image-gen-error');
        const approveBtn = document.getElementById('approve-images-generate-videos');
        const regenerateBtn = document.getElementById('regenerate-all-images');

        // Get settings
        const model = document.getElementById('nb-model').value;
        const resolution = document.getElementById('nb-resolution').value;
        const useReference = document.getElementById('nb-use-reference').value === 'yes';

        // Map video aspect ratio to Nano Banana format
        const aspectRatioMap = {
          '720x1280': '9:16',
          '1080x1920': '9:16',
          '1280x720': '16:9',
          '1920x1080': '16:9',
          '1080x1080': '1:1'
        };
        const aspectRatio = aspectRatioMap[videoSettings.aspectRatio] || '9:16';

        // Get reference images if enabled
        const referenceImages = [];
        if (useReference && characterProfile?.imageUrl) {
          referenceImages.push(characterProfile.imageUrl);
        }

        status.classList.remove('hidden');
        statusText.textContent = 'Generating preview images...';
        progressText.textContent = `0 of ${scenarios.length} scenes`;
        error.classList.add('hidden');
        grid.innerHTML = '';
        approveBtn.disabled = true;
        regenerateBtn.disabled = true;
        previewImages = [];

        // Generate images for each scenario
        for (let i = 0; i < scenarios.length; i++) {
          const scene = scenarios[i];
          progressText.textContent = `${i + 1} of ${scenarios.length} scenes`;

          // Create image card
          const imageCard = document.createElement('div');
          imageCard.className = 'preview-image-card';
          imageCard.id = `preview-image-${i}`;
          imageCard.style.cssText = 'padding: 16px; border-radius: 12px; border: 1px solid var(--border-subtle); background: rgba(15, 23, 42, 0.6);';
          imageCard.innerHTML = `
            <div style="font-size: 0.9rem; font-weight: 600; margin-bottom: 8px; color: var(--accent);">
              Scene ${i + 1}: ${scene.hook || scene.description || 'Untitled'}
            </div>
            <div class="image-container" id="image-container-${i}" style="min-height: 200px; background: #000; border-radius: 8px; display: flex; align-items: center; justify-content: center; color: var(--text-muted); overflow: hidden;">
              <div style="text-align: center;">
                <div style="font-size: 2rem; animation: spin 2s linear infinite;">üçå</div>
                <div style="margin-top: 8px;">Generating...</div>
              </div>
            </div>
            <div class="image-actions" id="image-actions-${i}" style="display: none; margin-top: 8px; display: flex; gap: 8px;">
              <button class="btn btn-secondary btn-sm" onclick="regenerateImage(${i})" style="flex: 1;">üîÑ Regenerate</button>
            </div>
          `;
          grid.appendChild(imageCard);

          // Generate image
          try {
            const prompt = scene.prompt || scene.sceneDescription || scene.description;
            
            const response = await fetch('/api/images/generate', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                prompt: prompt + getVoicePromptSuffix(),
                aspectRatio,
                resolution,
                referenceImages,
                model,
                saveToCloudinary: true
              })
            });

            if (!response.ok) {
              const errData = await response.json();
              throw new Error(errData.error || errData.message || 'Failed to generate image');
            }

            const result = await response.json();
            
            // Store result
            previewImages[i] = result;

            // Update UI
            const container = document.getElementById(`image-container-${i}`);
            const imageSrc = result.imageUrl || `data:${result.mimeType};base64,${result.imageBase64}`;
            container.innerHTML = `
              <img src="${imageSrc}" alt="Scene ${i + 1} preview" style="width: 100%; height: auto; border-radius: 8px; cursor: pointer;" onclick="window.open('${imageSrc}', '_blank')" />
            `;
            
            const actions = document.getElementById(`image-actions-${i}`);
            actions.style.display = 'flex';

          } catch (err) {
            console.error(`Image ${i + 1} generation failed:`, err);
            const container = document.getElementById(`image-container-${i}`);
            container.innerHTML = `
              <div style="text-align: center; color: var(--danger);">
                <div style="font-size: 1.5rem;">‚ùå</div>
                <div style="margin-top: 8px; font-size: 0.8rem;">${err.message}</div>
              </div>
            `;
          }

          // Small delay between generations
          if (i < scenarios.length - 1) {
            await new Promise(resolve => setTimeout(resolve, 300));
          }
        }

        // Complete
        const successCount = previewImages.filter(Boolean).length;
        status.classList.add('hidden');
        
        if (successCount > 0) {
          approveBtn.disabled = false;
          regenerateBtn.disabled = false;
        }
        
        if (successCount < scenarios.length) {
          error.textContent = `‚ö†Ô∏è ${scenarios.length - successCount} image(s) failed to generate. You can regenerate them individually.`;
          error.classList.remove('hidden');
        }
      }

      // Regenerate a single image
      async function regenerateImage(idx) {
        const container = document.getElementById(`image-container-${idx}`);
        const scene = scenarios[idx];
        
        container.innerHTML = `
          <div style="text-align: center;">
            <div style="font-size: 2rem; animation: spin 2s linear infinite;">üçå</div>
            <div style="margin-top: 8px;">Regenerating...</div>
          </div>
        `;

        const model = document.getElementById('nb-model').value;
        const resolution = document.getElementById('nb-resolution').value;
        const useReference = document.getElementById('nb-use-reference').value === 'yes';
        
        const aspectRatioMap = {
          '720x1280': '9:16',
          '1080x1920': '9:16',
          '1280x720': '16:9',
          '1920x1080': '16:9',
          '1080x1080': '1:1'
        };
        const aspectRatio = aspectRatioMap[videoSettings.aspectRatio] || '9:16';

        const referenceImages = [];
        if (useReference && characterProfile?.imageUrl) {
          referenceImages.push(characterProfile.imageUrl);
        }

        try {
          const prompt = scene.prompt || scene.sceneDescription || scene.description;
          
          const response = await fetch('/api/images/generate', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              prompt: prompt + getVoicePromptSuffix(),
              aspectRatio,
              resolution,
              referenceImages,
              model,
              saveToCloudinary: true
            })
          });

          if (!response.ok) {
            const errData = await response.json();
            throw new Error(errData.error || errData.message || 'Failed to regenerate image');
          }

          const result = await response.json();
          previewImages[idx] = result;

          const imageSrc = result.imageUrl || `data:${result.mimeType};base64,${result.imageBase64}`;
          container.innerHTML = `
            <img src="${imageSrc}" alt="Scene ${idx + 1} preview" style="width: 100%; height: auto; border-radius: 8px; cursor: pointer;" onclick="window.open('${imageSrc}', '_blank')" />
          `;

        } catch (err) {
          console.error(`Image ${idx + 1} regeneration failed:`, err);
          container.innerHTML = `
            <div style="text-align: center; color: var(--danger);">
              <div style="font-size: 1.5rem;">‚ùå</div>
              <div style="margin-top: 8px; font-size: 0.8rem;">${err.message}</div>
            </div>
          `;
        }
      }

      // Step 6: Video Generation
      document.getElementById('back-to-step-5').addEventListener('click', () => goToStep(5));

      async function startVideoGeneration() {
        const grid = document.getElementById('video-grid');
        const status = document.getElementById('generation-status');
        const error = document.getElementById('generation-error');

        // Check if A/B mode is enabled
        const isABMode = document.getElementById('ab-generation')?.checked || false;

        // Check if we have either a file upload OR a saved character with image URL
        const hasImageFile = !!characterImageFile;
        const hasImageUrl = characterProfile?.imageUrl;
        
        if (!hasImageFile && !hasImageUrl) {
          error.textContent = 'Character image not found. Please go back and upload a character image or select a saved character with an image.';
          error.classList.remove('hidden');
          return;
        }
        
        // If A/B mode, duplicate each scenario
        let scenariosToGenerate = [...scenarios];
        if (isABMode) {
          scenariosToGenerate = scenarios.flatMap((scene, idx) => [
            { ...scene, variant: 'A', originalIdx: idx },
            { ...scene, variant: 'B', originalIdx: idx, prompt: scene.prompt + '\n\n[ALTERNATIVE TAKE: Different camera angle and timing variation]' }
          ]);
        }

        status.classList.remove('hidden');
        status.textContent = isABMode 
          ? `üé¨ Starting A/B video generation (${scenariosToGenerate.length} videos)...`
          : 'üé¨ Starting video generation...';
        error.classList.add('hidden');
        grid.innerHTML = '';

        // Generate videos for all scenarios
        for (let i = 0; i < scenariosToGenerate.length; i++) {
          const scene = scenariosToGenerate[i];
          const variantLabel = scene.variant ? ` (${scene.variant})` : '';
          
          // Create video card
          const videoCard = document.createElement('div');
          videoCard.className = 'video-card';
          videoCard.id = `video-card-${i}`;
          const sceneNum = scene.originalIdx !== undefined ? scene.originalIdx + 1 : i + 1;
          videoCard.innerHTML = `
            <div class="card-body">
              <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 8px;">
              <div class="card-title">
                  <strong>Scene ${sceneNum}${variantLabel}:</strong> ${scene.hook || scene.description || 'Untitled'}
              </div>
                <button class="favorite-btn" id="fav-${i}" onclick="toggleFavorite(${i})" title="Add to favorites">ü§ç</button>
              </div>
              <div style="display: flex; align-items: center; gap: 12px;">
              <div class="status-pill status-pending" id="status-${i}">Queued</div>
                <!-- Rating Stars -->
                <div class="rating-stars" id="rating-${i}" style="display: none;">
                  <span class="rating-star" onclick="rateVideo(${i}, 1)">‚≠ê</span>
                  <span class="rating-star" onclick="rateVideo(${i}, 2)">‚≠ê</span>
                  <span class="rating-star" onclick="rateVideo(${i}, 3)">‚≠ê</span>
                  <span class="rating-star" onclick="rateVideo(${i}, 4)">‚≠ê</span>
                  <span class="rating-star" onclick="rateVideo(${i}, 5)">‚≠ê</span>
                </div>
              </div>
              <div style="margin-top: 8px; font-size: 0.8rem; color: var(--text-muted);" id="progress-${i}">
                Waiting to start...
              </div>
              <div class="video-container" id="video-container-${i}" style="margin-top: 12px; min-height: 200px; background: #000; border-radius: 8px; display: flex; align-items: center; justify-content: center; color: var(--text-muted);">
                <div>‚è≥ Queued...</div>
              </div>
              <div class="card-actions" id="actions-${i}" style="display: none;">
                <button class="btn btn-secondary btn-sm" onclick="remixScene(${i})">üîÑ Remix</button>
                <button class="btn btn-secondary btn-sm" onclick="downloadScene(${i})">‚¨áÔ∏è Download</button>
                <button class="btn btn-secondary btn-sm" onclick="copyVideoPrompt(${i})">üìã Copy Prompt</button>
                <button class="btn btn-secondary btn-sm" id="save-permanent-${i}" onclick="savePermanently(${i})" title="Save to cloud storage forever">‚òÅÔ∏è Save</button>
              </div>
              <div id="storage-status-${i}" style="display: none; margin-top: 8px; padding: 6px 10px; border-radius: 6px; font-size: 0.75rem;"></div>
            </div>
          `;
          grid.appendChild(videoCard);

          // Generate video
          try {
            status.textContent = `‚è≥ Generating scene ${i + 1} of ${scenarios.length}...`;
            
            // Update status
            const statusPill = document.getElementById(`status-${i}`);
            const progressText = document.getElementById(`progress-${i}`);
            const videoContainer = document.getElementById(`video-container-${i}`);
            
            statusPill.textContent = 'Generating...';
            statusPill.className = 'status-pill status-pending';
            progressText.textContent = 'Sending to Sora API...';
            videoContainer.innerHTML = '<div>üé¨ Generating with Sora 2...</div>';

            // Create form data with video settings
            const formData = new FormData();
            
            // Build final prompt with voice consistency
            const basePrompt = scene.prompt || scene.sceneDescription;
            const voiceSuffix = getVoicePromptSuffix();
            const finalPrompt = basePrompt + voiceSuffix;
            
            formData.append('prompt', finalPrompt);
            formData.append('seconds', videoSettings.duration);
            formData.append('size', videoSettings.aspectRatio);
            
            // Either use uploaded file or image URL from saved character
            if (characterImageFile) {
            formData.append('image', characterImageFile);
            } else if (characterProfile?.imageUrl) {
              formData.append('imageUrl', characterProfile.imageUrl);
            }

            // Start generation
            const generateRes = await fetch('/api/generate', {
              method: 'POST',
              body: formData
            });

            if (!generateRes.ok) {
              throw new Error('Failed to start video generation');
            }

            const videoJob = await generateRes.json();
            scene.videoId = videoJob.id;

            // Poll for completion with error handling
            progressText.textContent = 'Video generation in progress...';
            
            let completed = false;
            let errorCount = 0;
            const maxErrors = 5;
            
            while (!completed) {
              try {
                await new Promise(resolve => setTimeout(resolve, 3000)); // Poll every 3 seconds

                const statusRes = await fetch(`/api/status/${videoJob.id}`);
                
                if (!statusRes.ok) {
                  const errorData = await statusRes.json().catch(() => ({}));
                  
                  // Handle retryable OpenAI server errors
                  if (errorData.retryable) {
                    errorCount++;
                    progressText.textContent = `‚ö†Ô∏è OpenAI server issue, retrying... (${errorCount}/${maxErrors})`;
                    
                    if (errorCount >= maxErrors) {
                      throw new Error('OpenAI servers are experiencing issues. Please try again later.');
                    }
                    
                    await new Promise(resolve => setTimeout(resolve, 5000));
                    continue;
                  }
                  
                  throw new Error(errorData.error || 'Failed to check video status');
                }

                // Reset error count on success
                errorCount = 0;
                
                const jobStatus = await statusRes.json();
                const progress = jobStatus.progress || 0;

                if (jobStatus.status === 'completed') {
                  completed = true;
                  statusPill.textContent = 'Completed';
                  statusPill.className = 'status-pill status-ok';
                  progressText.textContent = '‚úÖ Video ready!';
                  
                  // Show video
                  videoContainer.innerHTML = `
                    <video controls style="width: 100%; border-radius: 8px;">
                      <source src="/api/download/${videoJob.id}" type="video/mp4">
                    </video>
                  `;

                  // Show action buttons and rating stars
                  document.getElementById(`actions-${i}`).style.display = 'flex';
                  document.getElementById(`rating-${i}`).style.display = 'flex';
                  
                  // Store video data for favorites/ratings
                  generatedVideos[i] = {
                    id: 'vid_' + Date.now() + '_' + i,
                    soraJobId: videoJob.id,
                    prompt: scene.prompt || scene.sceneDescription,
                    isFavorite: false,
                    rating: 0
                  };

                  // SAVE VIDEO TO DATABASE
                  try {
                    await fetch('/api/videos/save', {
                      method: 'POST',
                      headers: { 'Content-Type': 'application/json' },
                      body: JSON.stringify({
                        id: 'vid_' + Date.now() + '_' + i,
                        projectId: window.currentProjectId || null,
                        soraJobId: videoJob.id,
                        prompt: scene.prompt || scene.sceneDescription,
                        structuredPrompt: scene,
                        status: 'completed',
                        durationSeconds: videoSettings.duration
                      })
                    });
                    console.log('‚úÖ Video saved to DB');
                  } catch (saveErr) {
                    console.warn('Could not save video:', saveErr);
                  }

                } else if (jobStatus.status === 'failed') {
                  throw new Error('Video generation failed');
                } else {
                  // Update progress
                  progressText.textContent = `${jobStatus.status} - ${Math.round(progress)}%`;
                }
              } catch (err) {
                if (err.message.includes('OpenAI servers')) {
                  throw err; // Don't retry if we've exceeded max errors
                }
                
                errorCount++;
                if (errorCount >= maxErrors) {
                  throw err;
                }
                
                progressText.textContent = `‚ö†Ô∏è Temporary error, retrying... (${errorCount}/${maxErrors})`;
                await new Promise(resolve => setTimeout(resolve, 5000));
              }
            }

          } catch (err) {
            console.error(`Scene ${i + 1} error:`, err);
            const statusPill = document.getElementById(`status-${i}`);
            const progressText = document.getElementById(`progress-${i}`);
            const videoContainer = document.getElementById(`video-container-${i}`);
            
            statusPill.textContent = 'Failed';
            statusPill.className = 'status-pill status-error';
            progressText.textContent = `‚ùå ${err.message}`;
            videoContainer.innerHTML = `<div style="color: var(--danger);">Generation failed</div>`;
          }
        }

        status.textContent = `‚úÖ Completed ${scenarios.length} scene(s)!`;
      }

      // Remix scene function
      window.remixScene = async function(sceneIndex) {
        const scene = scenarios[sceneIndex];
        if (!scene.videoId) return;

        const newPrompt = prompt('Enter remix prompt (describe specific change):', 'Make it more dramatic');
        if (!newPrompt) return;

        const statusPill = document.getElementById(`status-${sceneIndex}`);
        const progressText = document.getElementById(`progress-${sceneIndex}`);
        const videoContainer = document.getElementById(`video-container-${sceneIndex}`);

        try {
          statusPill.textContent = 'Remixing...';
          statusPill.className = 'status-pill status-pending';
          progressText.textContent = 'Sending remix request...';

          const res = await fetch('/api/remix', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              videoId: scene.videoId,
              prompt: newPrompt
            })
          });

          if (!res.ok) throw new Error('Failed to start remix');

          const remixJob = await res.json();
          
          // Poll for remix completion
          let completed = false;
          while (!completed) {
            await new Promise(resolve => setTimeout(resolve, 3000));

            const statusRes = await fetch(`/api/status/${remixJob.id}`);
            const jobStatus = await statusRes.json();

            if (jobStatus.status === 'completed') {
              completed = true;
              scene.videoId = remixJob.id; // Update with new video
              
              statusPill.textContent = 'Remixed';
              statusPill.className = 'status-pill status-ok';
              progressText.textContent = '‚úÖ Remix complete!';
              
              videoContainer.innerHTML = `
                <video controls style="width: 100%; border-radius: 8px;">
                  <source src="/api/download/${remixJob.id}" type="video/mp4">
                </video>
              `;
            } else if (jobStatus.status === 'failed') {
              throw new Error('Remix failed');
            } else {
              progressText.textContent = `Remixing - ${jobStatus.status}...`;
            }
          }
        } catch (err) {
          statusPill.textContent = 'Failed';
          statusPill.className = 'status-pill status-error';
          progressText.textContent = `‚ùå ${err.message}`;
        }
      };

      // Download scene function
      window.downloadScene = function(sceneIndex) {
        const scene = scenariosToGenerate?.[sceneIndex] || scenarios[sceneIndex];
        if (!scene?.videoId) return;
        window.open(`/api/download/${scene.videoId}`, '_blank');
      };

      // Store generated videos data for favorites/ratings
      let generatedVideos = [];
      let scenariosToGenerate = [];

      // Toggle favorite
      window.toggleFavorite = async function(idx) {
        const btn = document.getElementById(`fav-${idx}`);
        const video = generatedVideos[idx];
        
        if (btn.classList.contains('favorited')) {
          btn.classList.remove('favorited');
          btn.textContent = 'ü§ç';
          if (video) video.isFavorite = false;
        } else {
          btn.classList.add('favorited');
          btn.textContent = '‚ù§Ô∏è';
          if (video) video.isFavorite = true;
        }

        // Save to database
        if (video?.id) {
          try {
            await fetch('/api/videos/favorite', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ id: video.id, isFavorite: video.isFavorite })
            });
          } catch (err) {
            console.warn('Could not save favorite:', err);
          }
        }
      };

      // Rate video
      window.rateVideo = async function(idx, rating) {
        const ratingContainer = document.getElementById(`rating-${idx}`);
        const stars = ratingContainer.querySelectorAll('.rating-star');
        const video = generatedVideos[idx];
        
        stars.forEach((star, starIdx) => {
          star.classList.toggle('active', starIdx < rating);
        });
        
        if (video) video.rating = rating;

        // Save to database
        if (video?.id) {
          try {
            await fetch('/api/videos/rate', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ id: video.id, rating: rating })
            });
          } catch (err) {
            console.warn('Could not save rating:', err);
          }
        }
      };

      // Copy video prompt
      window.copyVideoPrompt = async function(idx) {
        const scene = scenariosToGenerate[idx] || scenarios[idx];
        if (!scene) return;
        
        const fullPrompt = (scene.prompt || scene.sceneDescription || '') + getVoicePromptSuffix();
        
        try {
          await navigator.clipboard.writeText(fullPrompt);
          alert('‚úì Prompt copied to clipboard!');
        } catch (err) {
          console.error('Failed to copy:', err);
        }
      };

      // Save video permanently to Cloudinary
      window.savePermanently = async function(idx) {
        const video = generatedVideos[idx];
        if (!video?.soraJobId) {
          alert('Video not ready yet');
          return;
        }

        const btn = document.getElementById(`save-permanent-${idx}`);
        const statusDiv = document.getElementById(`storage-status-${idx}`);
        
        btn.disabled = true;
        btn.textContent = '‚òÅÔ∏è Saving...';
        statusDiv.style.display = 'block';
        statusDiv.style.background = 'rgba(251, 191, 36, 0.2)';
        statusDiv.style.color = '#fbbf24';
        statusDiv.textContent = '‚è≥ Uploading to cloud storage...';

        try {
          const res = await fetch('/api/videos/save-permanent', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              soraJobId: video.soraJobId,
              videoId: video.id
            })
          });

          const result = await res.json();

          if (!res.ok) {
            throw new Error(result.message || result.error || 'Failed to save');
          }

          // Success!
          btn.textContent = '‚úì Saved';
          btn.style.borderColor = 'var(--accent-green)';
          btn.style.color = 'var(--accent-green)';
          statusDiv.style.background = 'rgba(52, 211, 153, 0.2)';
          statusDiv.style.color = '#34d399';
          statusDiv.innerHTML = `‚úì Permanently saved! <a href="${result.permanentUrl}" target="_blank" style="color: inherit;">View ‚Üí</a>`;
          
          // Update video source to permanent URL
          const videoContainer = document.getElementById(`video-container-${idx}`);
          if (videoContainer && result.permanentUrl) {
            const videoEl = videoContainer.querySelector('video');
            if (videoEl) {
              videoEl.src = result.permanentUrl;
            }
          }

          video.permanentUrl = result.permanentUrl;

        } catch (err) {
          console.error('Save permanent error:', err);
          btn.disabled = false;
          btn.textContent = '‚òÅÔ∏è Save';
          statusDiv.style.background = 'rgba(248, 113, 113, 0.2)';
          statusDiv.style.color = '#f87171';
          statusDiv.textContent = `‚ùå ${err.message}`;
        }
      };

      // Check storage configuration on load
      async function checkStorageStatus() {
        try {
          const res = await fetch('/api/storage/status');
          const status = await res.json();
          
          if (!status.cloudinary.configured) {
            console.warn('‚òÅÔ∏è Cloudinary not configured - videos will not be permanently stored');
          }
        } catch (err) {
          console.warn('Could not check storage status:', err);
        }
      }
      
      checkStorageStatus();
    </script>
  </body>
</html>

